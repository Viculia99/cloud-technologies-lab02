<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>ЛР-01</title>
	<link rel="stylesheet" href="main.css">
</head>
<body class="body">
	<header class="header">
		<h3 class="main-title">Функціональне програмування</h3>
	</header>

<div class="dropup">
<div class="dropbtn"></div>
<div class="dropbtn"></div>
<div class="dropbtn"></div>
  <div class="dropup-content">
  	<a href="index.html">Головна</a>
    <a href="lab-01.html">ЛР-01</a>
    <a href="lab-02.html">ЛР-02</a>
    <a href="lab-03.html">ЛР-03</a>
    <a href="#">ЛР-04</a>
    <a href="lab-05.html">ЛР-05</a>
  </div>

<div class="main-page">
	<h1 class="lab-01"><b>Лабораторна робота №1</b></h1>
	
	<p class="theme">
	<b>Тема:</b>
	Використання рекурсії для організації повторювальних процесів</p>	

	<p class="meta">
	<b>Мета:</b>
	Сформувати декларативне мислення в галузі програмування завдяки використанню чистих функцій, рекурсій замість циклів, запобіганню даних, що змінюються. Опанувати застосування рекурсивних функцій для обчислювальних процесів</p>	
	<div><b>Варіант:</b>
	11</div>
	<div class="tasks">
	<p><b>Завдання:</b></p>
	<p><b>11.1.</b>Послідовність 1, 1, 2, 3, 5, 8, ... складається з чисел Фібоначчі. Кожен елемент, починаючи з третього, дорівнює сумі двох попередніх. Рекурентне співвідношення для розрахунку чисел Фібоначчі таке:</p>	
	<img src="task-lab-1.jpg">
	<p>Ввести з клавіатури два натуральних числа   m   та   n, які означають кількість чисел та номер числа в послідовності Фібоначчі. Вивести послідовність чисел Фібоначчі в кількості   m   елементів та значення   n-го числа. Передбачити випадок   m   <   n. Визначити глибину рекурсії.</p>

	<p><b>11.2</b> Створити рекурсивну функцію, яка отримує числа, зчитуючи їх з клавіатури, і перевіряє їх на непарність. Кінець вводу - число 0. Функція не повертає значення, а відразу ж виводить результат на екран, зберігаючи порядок ведених чисел. У цьому завданні   не можна   використовувати глобальні змінні і передавати будь-які аргументи в рекурсивну функцію. Основна програма повинна складатися тільки з виклику цієї функції. Контрольний тест: введені числа 3 2 1 0, отриманий результат: 3 1.</p>
	</div>	

	<div class="structure">
		<p class="struct-title"><b>Опис алгоритму роботи програми 11.1:</b>
		<ol>
   <li>Отримуємо число n</li>
   <li>Формуємо послідовність чисел Фібоначчі<br> за допомогою функції <b>build-list</b></li>
   	<li>Перевіряємо, чи n<2</li>
    <li>Якщо n<2, виводимо 1</li>
    <li>Якщо n>2, обчислюємо послідовність Фібоначчі за рекурентним співвідношенням</li>
    <li>Викликаємо функцію</li>
    <li>Виводимо результат</li>
	</ol>
</p>

<p class="struct-title"><b>Опис алгоритму роботи програми 11.2:</b>
		<ol>
   <li>Отримуємо список чисел</li>
   <li>Перевіряємо чи число в списку є парним</li>
   <li>Якщо число парне, не додаємо в список</li>
   <li>Якщо число непарне, додаємо таке число в список</li>
    <li>Викликаємо функцію</li>
    <li>Виводимо результат</li>
	</ol>
</p>
</div>
<! -- --> <div class="flow-chart">
		<p><b>Блок-схема алгоритму рекурсивної процедури 11.1:</b></p>
		<img src="flow-chart-11.1.jpg">
	</div>
	<div class="flow-chart">
		<p><b>Блок-схема алгоритму рекурсивної процедури11.2:</b></p>
		<img src="flow-chart-11.2.jpg">
</div>
	<div class="language">
		<p>
			<b>Обгрунтування вибору середовища та мови</b>
			<p>В якості середовища було обрано DrRacket версії 8.2 та мова Racket</p>
			<p>Вибір середовища та мови був зумовлений наступним:
			<li>DrRacket та мова Racket  мають хорошу документацію <a href="https://docs.racket-lang.org/" target="_blank">https://docs.racket-lang.org</a></li>
			<li>дане середовище та мова були рекомендовані викладачем</li>
  			</p>
		</p>
	</div>
	<div>
		 <p><b>Код програми:</b></p>
		 <div class="code">
		 	#lang racket
; Task 11.1<br>
(define (fibo n)<br>
  (first<br>
   (foldr (lambda (no-use ls) (list (second ls) (+ (first ls) (second ls))))<br>
          '(0 1)<br>
          (build-list n (lambda (x) x)))); вивід послідовності Фібоначчі з використанням lambda функції<br>
  (if (<= n 2)<br>
      1<br>
      (+ (fibo (- n 1)) (fibo (- n 2)))))<br>

; Task 11.2<br>

(define (filter-odd lst)<br>
 (filter (lambda (x)(= (modulo x 2) 1)) lst))<br>

(display "#Task 11.1#\n")<br>
(display "The Fibonacci sequence:")<br>
(build-list 15 fibo)<br>
(display "The sum of Fibonacci sequence=")<br>
(fibo 15)<br>

(display "#Task 11.2#\n")<br>
(display "Task Result=")<br>
(define numbers (list 3 2 1 0))<br>
(filter-odd numbers)<br>
		 </div>
	</div>
	<div class="screen">
		<p><b>Скріншоти результатів:</b></p>
		<img src="lab-01-11.1.jpg">
		<img src="lab-01-11.2.jpg">
	</div>
	<div class="conclusions">
	<p><b>Висновки:</b></p>
	<p>В ході виконання даної лабораторної роботи було сформовано декларативне мислення в галузі програмування завдяки використанню чистих функцій, рекурсій замість циклів, запобіганню даних, що змінюються.<br> Опановано застосування рекурсивних функцій для обчислювальних процесів, на прикладі вирішення  наступних завдань: 
		<li>Виведення суми чисел в послідовності Фібоначчі в кількості   m   елементів та значення   n-го числа. </li>
		<li>В результаті виконання даної програми було встановлено, що при виведенні послідовності Фібоначчі на початку виводиться зайва 1</li>
		<li>Глибину рекурсії визначено не було</li>

		<li>Створено рекурсивну функцію, яка отримує числа, зчитуючи їх з клавіатури, і перевіряє їх на непарність.</li>
		<li>Для виконання даного завдання було додатково вивчено матеріали про списки, за допомогою яких і було реалізовано програму</li>
	</p>
</div>
</div>
</body>
</html>